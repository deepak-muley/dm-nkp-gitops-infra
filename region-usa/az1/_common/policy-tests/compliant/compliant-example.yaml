# Compliant Example - Best Practices Pod/Deployment
# This resource demonstrates a fully compliant workload that passes all policies
#
# This example shows:
# - Non-root user (runAsNonRoot: true) with high UID/GID (>10000)
# - Read-only root filesystem with writable volume
# - Resource requests and limits
# - Health probes
# - Standard labels
# - Non-default ServiceAccount
# - Disabled service account token automount
# - Proper security context (hostUsers: false, seccomp profile)
# - Image digest (required by require-image-digest policy)
#
# To verify compliance:
#   kubectl apply -f region-usa/az1/_common/policy-tests/compliant/compliant-example.yaml
#   kubectl get policyreport -n policy-tests-compliant
#   kubectl get constraints -A | grep policy-tests-compliant
#
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: compliant-app-sa
  namespace: policy-tests-compliant
  labels:
    app.kubernetes.io/name: compliant-example
    app.kubernetes.io/component: serviceaccount
    app.kubernetes.io/part-of: policy-tests
    policy-test-type: "positive"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: compliant-app-config
  namespace: policy-tests-compliant
  labels:
    app.kubernetes.io/name: compliant-example
    app.kubernetes.io/component: config
    app.kubernetes.io/part-of: policy-tests
    policy-test-type: "positive"
data:
  config.yaml: |
    server:
      port: 8080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compliant-example
  namespace: policy-tests-compliant
  labels:
    app.kubernetes.io/name: compliant-example
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/component: application
    app.kubernetes.io/part-of: policy-tests
    policy-test-type: "positive"
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: compliant-example
  template:
    metadata:
      labels:
        app.kubernetes.io/name: compliant-example
        app.kubernetes.io/version: "1.0.0"
        app.kubernetes.io/component: application
    spec:
      # Use non-default ServiceAccount
      serviceAccountName: compliant-app-sa
      # Disable service account token automount
      automountServiceAccountToken: false
      securityContext:
        # Run as non-root at pod level
        runAsNonRoot: true
        # Use high UID/GID (>10000) to avoid conflicts with host users/groups (KubeSec recommendation)
        runAsUser: 10001
        runAsGroup: 10001
        fsGroup: 10001
        # Note: hostUsers: false requires Kubernetes 1.25+ and user namespace support in container runtime
        # This field is commented out as it may not be recognized by all validation tools/schemas
        # Uncomment if your cluster supports user namespaces (Kubernetes 1.25+):
        # hostUsers: false
        # Seccomp profile for additional security
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: app
        # Use image digest for immutability (required by require-image-digest policy)
        # NOTE: This is an example digest. In practice, get the actual digest for your image:
        #   docker pull busybox:1.36
        #   docker inspect busybox:1.36 | grep -A 5 RepoDigests
        # Or: docker images --digests busybox:1.36
        # Format: image@sha256:digest
        image: busybox@sha256:1ff6c18fbef2045af6b9c16bf034cc421a29027b800e4f9b68ae9b1cb3e9ae07
        imagePullPolicy: IfNotPresent
        command: ['sh', '-c', 'sleep 3600']
        securityContext:
          # Ensure non-root at container level
          runAsNonRoot: true
          # Use high UID (>10000) to avoid conflicts with host users
          runAsUser: 10001
          allowPrivilegeEscalation: false
          # Read-only root filesystem
          readOnlyRootFilesystem: true
          # Drop all capabilities
          capabilities:
            drop:
            - ALL
        # Resource requests and limits
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        # Health probes
        livenessProbe:
          exec:
            command:
            - sh
            - -c
            - "true"
          initialDelaySeconds: 10
          periodSeconds: 30
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          exec:
            command:
            - sh
            - -c
            - "true"
          initialDelaySeconds: 5
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        # Volume mounts for writable directories
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: var-run
          mountPath: /var/run
        - name: config
          mountPath: /etc/config
          readOnly: true
      volumes:
      - name: tmp
        emptyDir: {}
      - name: var-run
        emptyDir: {}
      - name: config
        configMap:
          name: compliant-app-config
---
apiVersion: v1
kind: Service
metadata:
  name: compliant-example
  namespace: policy-tests-compliant
  labels:
    app.kubernetes.io/name: compliant-example
    app.kubernetes.io/component: service
    app.kubernetes.io/part-of: policy-tests
    policy-test-type: "positive"
spec:
  # Use ClusterIP, not NodePort or LoadBalancer
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app.kubernetes.io/name: compliant-example
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: compliant-example
  namespace: policy-tests-compliant
  labels:
    app.kubernetes.io/name: compliant-example
    app.kubernetes.io/component: ingress
    app.kubernetes.io/part-of: policy-tests
    policy-test-type: "positive"
spec:
  # TLS configuration required
  tls:
  - hosts:
    - compliant-example.example.com
    secretName: compliant-example-tls
  rules:
  - host: compliant-example.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: compliant-example
            port:
              number: 80

